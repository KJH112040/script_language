# # 메모리를 적절히 재사용 -> 이미 해결한 문제를 메모리에 저장해놓고 재사용
# # dp table
# d = [0]*100
# # 피보나치 재귀함수에서 탑다운 다이나믹 프로그래밍
# def fibo(x):
#     if x == 1 or x == 2:
#         return 1
#     # 이미 계산한 결과가 있다면 재사용
#     if d[x] != 0:
#         return d[x]
#     # 아직 계산하지 않은 문제라면 점화식으로 재귀 호출
#     d[x] = fibo(x-1)+fibo(x-2)
#     return d[x]
#
# def fibo2(x):
#     if x == 1 or x == 2:
#         return 1
#     # 점화식으로 재귀 호출
#     return fibo2(x-1)+fibo(x-2)
#
# #print(fibo(99))
# #print(fibo2(99))
# # 결과값: 218922995834555169026
#
# d[1] = 1
# d[2] = 1
# n = 99
# # 피보나치 함수를 반복문으로 바텀업 다이나믹 프로그래밍
# for i in range(3,n+1):
#     d[i] = d[i - 1] + d[i - 2]
# print(d[n])
# # 결과값: 218922995834555169026
#
# # 분할 정복은 중복이 안 된다. ex. quick sort
# # ---> 중복이 되지 않기 때문에 다이나믹 프로그래밍으로 풀 수 없음(중복이 되지 않아 재사용 못 하기 때문)
# # 점화식을 잘 세워야 함.
#===============================================================================================
# # [문제] 개미 전사
# # 개미 전사 문제 점화식
# # ai = max(ai-1,ai-2+ki)
# # 정수 N 입력
# n = int(input())
# # 모든 식량 정보 입력
# array = list(map(int,input().split()))
# # dp table 0으로 초기화, 식량 창고 3<=N<=100
# d = [0] * 100
# # 다이나믹 프로그래밍 바텀업
# d[0] = array[0]
# d[1] = max(array[0],array[1])
# for i in range(2, n):
#     d[i] = max(d[i-1],d[i-2]+array[i])
# print(d[n-1])
# # 입력
# # 4
# # 1 3 1 5
# # 출력
# # 8
# # 입력
# # 10
# # 3 1 3 1 3 1 3 1 3 1
# # 출력
# # 15
#===========================================================
# # 정수 x 입력
# # 점화식
# # ai : i를 1로 만들기 위한 최소 연산 횟수
# # ai = min(ai-1,ai/2,ai/3,ai/5) + 1
# x  = int(input())
# # dp 테이블
# d = [0]*30001
# # d[1] = 0
# # 다이나믹 프로그래밍 바텀업
# for i in range(2, x+1):
#     d[i] = d[i-1]+1     # 1 더하기
#     if i%2==0:      # i가 2로 나눠 떨엉지면
#         d[i] = min([d[i],d[i//2]+1])
#     if i % 3 == 0:  # i가 3로 나눠 떨엉지면
#         d[i] = min([d[i], d[i // 3] + 1])
#     if i%5==0:      # i가 5로 나눠 떨엉지면
#         d[i] = min([d[i],d[i//5]+1])
# print(d[x])
#===============================================================